window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "scmkl", "modulename": "scmkl", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "scmkl.estimate_sigma", "modulename": "scmkl", "qualname": "estimate_sigma", "kind": "function", "doc": "<p>Function to calculate approximate kernels widths to inform distribution for project of Fourier Features. Calculates one sigma per group of features\nInput:\n        adata- Adata obj as created by <code>Create_Adata</code>\n        n_features- Number of random features to include when estimating sigma.  Will be scaled for the whole pathway set according to a heuristic. Used for scalability\nOutput:\n        adata object with sigma values.  Sigmas accessible by adata.uns['sigma']</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">adata</span>, </span><span class=\"param\"><span class=\"n\">n_features</span><span class=\"o\">=</span><span class=\"mi\">5000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.multimodal_processing", "modulename": "scmkl", "qualname": "multimodal_processing", "kind": "function", "doc": "<p>Function to remove rows from both modalities when there is no signal present in at least 1.</p>\n\n<p>Input:\n    adatas: a list of AnnData objects where each object is a different modality\n    names: a list of string names for each modality repective to each object in adatas\n    tfidf- list of boolean values whether to tfidf the respective matrices\n    z_calculation- Boolean value whether to calculate sigma and Z on the adata before combining\n                    Allows for individual kernel functions for each adata\nOutput:\n    adata- Concatenated adata objects with empty rows removed and matching order</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">adatas</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">names</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">tfidf</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">z_calculation</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.optimize_alpha", "modulename": "scmkl", "qualname": "optimize_alpha", "kind": "function", "doc": "<p>Iteratively train a grouplasso model and update alpha to find the parameter yielding the desired sparsity.\nThis function is meant to find a good starting point for your model, and the alpha may need further fine tuning.\nInput:\n    adata- Anndata object with Z_train and Z_test calculated\n    group_size- Argument describing how the features are grouped. \n        From Celer documentation:\n        \"groupsint | list of ints | list of lists of ints.\n            Partition of features used in the penalty on w. \n                If an int is passed, groups are contiguous blocks of features, of size groups. \n                If a list of ints is passed, groups are assumed to be contiguous, group number g being of size groups[g]. \n                If a list of lists of ints is passed, groups[g] contains the feature indices of the group number g.\"\n        If 1, model will behave identically to Lasso Regression.\n    tfidf- Boolean value to determine if TFIDF normalization should be run at each fold. True means that it will be performed.\n    starting_alpha- The alpha value to start the search at.\n    alpha_array- Numpy array of all alpha values to be tested\n    k- number of folds to perform cross validation over</p>\n\n<p>Output:\n    sparsity_dict- Dictionary with tested alpha as keys and the number of selected pathways as the values\n    alpha- The alpha value yielding the number of selected groups closest to the target.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">adata</span>,</span><span class=\"param\">\t<span class=\"n\">group_size</span>,</span><span class=\"param\">\t<span class=\"n\">tfidf</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">alpha_array</span><span class=\"o\">=</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">1.9</span><span class=\"p\">,</span> <span class=\"mf\">1.7</span><span class=\"p\">,</span> <span class=\"mf\">1.5</span><span class=\"p\">,</span> <span class=\"mf\">1.3</span><span class=\"p\">,</span> <span class=\"mf\">1.1</span><span class=\"p\">,</span> <span class=\"mf\">0.9</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">])</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.approx_kernels", "modulename": "scmkl.approx_kernels", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "scmkl.approx_kernels.calculate_z", "modulename": "scmkl.approx_kernels", "qualname": "calculate_z", "kind": "function", "doc": "<p>Function to calculate approximate kernels.\nInput:\n        adata- Adata obj as created by <code>Create_Adata</code>\n            Sigma can be calculated with Estimate_Sigma or a heuristic but must be positive.\n        n_features- Number of random feature to use when calculating Z- used for scalability\nOutput:\n        adata_object with Z matrices accessible with- adata.uns['Z_train'] and adata.uns['Z_test'] respectively</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">adata</span>, </span><span class=\"param\"><span class=\"n\">n_features</span><span class=\"o\">=</span><span class=\"mi\">5000</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span>:</span></span>", "funcdef": "def"}, {"fullname": "scmkl.atac_grouping", "modulename": "scmkl.atac_grouping", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "scmkl.atac_grouping.get_atac_groupings", "modulename": "scmkl.atac_grouping", "qualname": "get_atac_groupings", "kind": "function", "doc": "<p>Takes processed gene annotations in GTF format, and gene set \nlibrary, and feature names from a single-cell ATAC data matrix\nand creates an ATAC region set to be used with scMKL.\nArgs:\n    gene_anno - gene annotations in GTF format as a pd.DataFrame \n        with columns ['chr', 'start', 'end', 'strand', 'gene_name']\n    gene_sets - a dictionary with gene_set names as keys and an \n        iterable object of gene_names as values.\n    feature_names - an iterable, one dimension object containing \n        feature names corresponding to a single_cell ATAC data \n        matrix.\nReturns:\n    A dictionary where keys are the names from gene_sets and values\n    are a list of regions from feature_names that overlap with \n    promotor regions respective to genes in gene sets (i.e., if \n    ATAC feature in feature_names overlaps with promotor region \n    from a gene in a gene set from gene_sets, that region will be\n    added to the new dictionary under the respective gene set \n    name).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">gene_anno</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">frame</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span>,</span><span class=\"param\">\t<span class=\"n\">gene_sets</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">feature_names</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">|</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span> <span class=\"o\">|</span> <span class=\"nb\">list</span> <span class=\"o\">|</span> <span class=\"nb\">set</span>,</span><span class=\"param\">\t<span class=\"n\">len_up</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5000</span>,</span><span class=\"param\">\t<span class=\"n\">len_down</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5000</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "scmkl.data_processing", "modulename": "scmkl.data_processing", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "scmkl.data_processing.filter_features", "modulename": "scmkl.data_processing", "qualname": "filter_features", "kind": "function", "doc": "<p>Function to remove unused features from X matrix.  Any features not included in group_dict will be removed from the matrix.\nAlso puts the features in the same relative order (of included features)\nInput:\n        X- Data array. Can be Numpy array or Scipy Sparse Array\n        feature_names- Numpy array of corresponding feature names\n        group_dict- Dictionary containing feature grouping information.\n                    Example: {geneset: np.array(gene_1, gene_2, ..., gene_n)}\nOutput:\n        X- Data array containing data only for features in the group_dict\n        feature_names- Numpy array of corresponding feature names from group_dict</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">feature_names</span>, </span><span class=\"param\"><span class=\"n\">group_dict</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.data_processing.train_test_split", "modulename": "scmkl.data_processing", "qualname": "train_test_split", "kind": "function", "doc": "<p>Function to calculate training and testing indices for given dataset. If train indices are given, it will calculate the test indices.\n    If train_indices == None, then it calculates both indices, preserving the ratio of each label in y\nInput:\n        y- Numpy array of cell labels. Can have any number of classes for this function.\n        train_indices- Optional array of pre-determined training indices\n        seed_obj- Numpy random state used for random processes. Can be specified for reproducubility or set by default.\n        train_ratio- decimal value ratio of features in training:testing sets\nOutput:\n        train_indices- Array of indices of training cells\n        test_indices- Array of indices of testing cells</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">y</span>,</span><span class=\"param\">\t<span class=\"n\">train_indices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">seed_obj</span><span class=\"o\">=</span><span class=\"n\">Generator</span><span class=\"p\">(</span><span class=\"n\">PCG64</span><span class=\"p\">)</span> <span class=\"n\">at</span> <span class=\"mh\">0x7FC2DBC6F920</span>,</span><span class=\"param\">\t<span class=\"n\">train_ratio</span><span class=\"o\">=</span><span class=\"mf\">0.8</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.data_processing.sparse_var", "modulename": "scmkl.data_processing", "qualname": "sparse_var", "kind": "function", "doc": "<p>Function to calculate variance on a scipy sparse matrix.\nInput:\n    X- A scipy sparse or numpy array\n    axis- Determines which axis variance is calculated on. Same usage as Numpy\n        axis = 0 =&gt; column variances\n        axis = 1 =&gt; row variances\n        axis = None =&gt; total variance (calculated on all data)\nOutput:\n    var- Variance values calculated over the given axis</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.data_processing.process_data", "modulename": "scmkl.data_processing", "qualname": "process_data", "kind": "function", "doc": "<p>Function to preprocess data matrix according to type of data (counts- e.g. rna, or binary- atac)\nWill process test data according to parameters calculated from test data</p>\n\n<p>Input:\n    X_train- A scipy sparse or numpy array\n    X_train- A scipy sparse or numpy array\n    data_type- 'counts' or 'binary'.  Determines what preprocessing is applied to the data. \n        Log transforms and standard scales counts data\n        TFIDF filters ATAC data to remove uninformative columns\nOutput:\n    X_train, X_test- Numpy arrays with the process train/test data respectively.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X_train</span>, </span><span class=\"param\"><span class=\"n\">X_test</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">data_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;counts&#39;</span>, </span><span class=\"param\"><span class=\"n\">return_dense</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.data_processing.create_adata", "modulename": "scmkl.data_processing", "qualname": "create_adata", "kind": "function", "doc": "<p>Function to create an AnnData object to carry all relevant information going forward</p>\n\n<p>Input:\n    X- A data matrix of cells by features can be a numpy array, scipy sparse array or pandas dataframe (sparse array recommended for large datasets)\n    feature_names- A numpy array of feature names corresponding with the features in X\n    cell_labels- A numpy array of cell phenotypes corresponding with the cells in X.  Must be binary\n    group_dict- Dictionary containing feature grouping information.\n                    Example: {geneset: np.array(gene_1, gene_2, ..., gene_n)}\n    data_type- 'counts' or 'binary'.  Determines what preprocessing is applied to the data. \n        Log transforms and standard scales counts data\n        TFIDF filters binary data\n    split_data- Either numpy array of precalculated train/test split for the cells -or-\n                        None.  If None, the train test split will be calculated with balanced classes.\n    D- Number of Random Fourier Features used to calculate Z. Should be a positive integer.\n            Higher values of D will increase classification accuracy at the cost of computation time\n    remove_features- Bool whether to filter the features from the dataset.\n            Will remove features from X and feature_names not in group_dict and remove features from groupings not in feature_names\n    distance_metric- The pairwise distance metric used to estimate sigma.<br />\n            Must be one of the options used in scipy.spatial.distance.cdist\n    kernel_type- The approximated kernel function used to calculate Zs\n            Must be one of Gaussian, Laplacian, or Cauchy\n    random_state- Integer random_state used to set the seed for reproducibilty.\nOutput:\n    AnnData object with: \n        Data equal to the values in X- accessible with adata.X\n        Variable names equal to the values in feature_names- accessible with adata.var_names\n        Cell phenotypes equal to the values in cell_labels- accessible with adata.obs['labels']\n        Train/test split either as given or calculated in this function- accessible with adata.uns['train_indices'] and adata.uns['test_indices'] respectively\n        Grouping information equal to given group_dict- accessible with adata.uns['group_dict']\n        seed_obj with seed equal to 100 * random_state- accessible with adata.uns['seed_obj']\n        D- accessible with adata.uns['D']\n        Type of data to determine preprocessing steps- accessible with adata.uns['data_type']\n        Distance metric as given- accessible with adata.uns['distance_metric']\n        Kernel function as given- accessible with adata.uns['kernel_type']</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span>,</span><span class=\"param\">\t<span class=\"n\">feature_names</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">cell_labels</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">group_dict</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">data_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">split_data</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">D</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">remove_features</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">distance_metric</span><span class=\"o\">=</span><span class=\"s1\">&#39;euclidean&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">kernel_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;Gaussian&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.estimate_sigma", "modulename": "scmkl.estimate_sigma", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "scmkl.estimate_sigma.estimate_sigma", "modulename": "scmkl.estimate_sigma", "qualname": "estimate_sigma", "kind": "function", "doc": "<p>Function to calculate approximate kernels widths to inform distribution for project of Fourier Features. Calculates one sigma per group of features\nInput:\n        adata- Adata obj as created by <code>Create_Adata</code>\n        n_features- Number of random features to include when estimating sigma.  Will be scaled for the whole pathway set according to a heuristic. Used for scalability\nOutput:\n        adata object with sigma values.  Sigmas accessible by adata.uns['sigma']</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">adata</span>, </span><span class=\"param\"><span class=\"n\">n_features</span><span class=\"o\">=</span><span class=\"mi\">5000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.multimodal_processing", "modulename": "scmkl.multimodal_processing", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "scmkl.multimodal_processing.combine_modalities", "modulename": "scmkl.multimodal_processing", "qualname": "combine_modalities", "kind": "function", "doc": "<p>Combines data sets for multimodal classification.  Combined group names are assay+group_name\nInput:\n        adatas: a list of AnnData objects where each object is a different modality\n        names: a list of strings names for each modality repective to each object in adatas\n        combination: How to combine the matrices, either sum or concatenate\nOutput:\n        combined_adata: Adata object with the combined Z matrices and annotations.  Annotations must match</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">adatas</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">names</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">combination</span><span class=\"o\">=</span><span class=\"s1\">&#39;concatenate&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.multimodal_processing.multimodal_processing", "modulename": "scmkl.multimodal_processing", "qualname": "multimodal_processing", "kind": "function", "doc": "<p>Function to remove rows from both modalities when there is no signal present in at least 1.</p>\n\n<p>Input:\n    adatas: a list of AnnData objects where each object is a different modality\n    names: a list of string names for each modality repective to each object in adatas\n    tfidf- list of boolean values whether to tfidf the respective matrices\n    z_calculation- Boolean value whether to calculate sigma and Z on the adata before combining\n                    Allows for individual kernel functions for each adata\nOutput:\n    adata- Concatenated adata objects with empty rows removed and matching order</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">adatas</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">names</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">tfidf</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">z_calculation</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.optimize_alpha", "modulename": "scmkl.optimize_alpha", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "scmkl.optimize_alpha.optimize_alpha", "modulename": "scmkl.optimize_alpha", "qualname": "optimize_alpha", "kind": "function", "doc": "<p>Iteratively train a grouplasso model and update alpha to find the parameter yielding the desired sparsity.\nThis function is meant to find a good starting point for your model, and the alpha may need further fine tuning.\nInput:\n    adata- Anndata object with Z_train and Z_test calculated\n    group_size- Argument describing how the features are grouped. \n        From Celer documentation:\n        \"groupsint | list of ints | list of lists of ints.\n            Partition of features used in the penalty on w. \n                If an int is passed, groups are contiguous blocks of features, of size groups. \n                If a list of ints is passed, groups are assumed to be contiguous, group number g being of size groups[g]. \n                If a list of lists of ints is passed, groups[g] contains the feature indices of the group number g.\"\n        If 1, model will behave identically to Lasso Regression.\n    tfidf- Boolean value to determine if TFIDF normalization should be run at each fold. True means that it will be performed.\n    starting_alpha- The alpha value to start the search at.\n    alpha_array- Numpy array of all alpha values to be tested\n    k- number of folds to perform cross validation over</p>\n\n<p>Output:\n    sparsity_dict- Dictionary with tested alpha as keys and the number of selected pathways as the values\n    alpha- The alpha value yielding the number of selected groups closest to the target.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">adata</span>,</span><span class=\"param\">\t<span class=\"n\">group_size</span>,</span><span class=\"param\">\t<span class=\"n\">tfidf</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">alpha_array</span><span class=\"o\">=</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">1.9</span><span class=\"p\">,</span> <span class=\"mf\">1.7</span><span class=\"p\">,</span> <span class=\"mf\">1.5</span><span class=\"p\">,</span> <span class=\"mf\">1.3</span><span class=\"p\">,</span> <span class=\"mf\">1.1</span><span class=\"p\">,</span> <span class=\"mf\">0.9</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">])</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.optimize_alpha.multimodal_optimize_alpha", "modulename": "scmkl.optimize_alpha", "qualname": "multimodal_optimize_alpha", "kind": "function", "doc": "<p>Iteratively train a grouplasso model and update alpha to find the parameter yielding the desired sparsity.\nThis function is meant to find a good starting point for your model, and the alpha may need further fine tuning.\nInput:\n    adatas- a list of AnnData objects where each object is one modality and Z_train and Z_test are calculated\n    group_size- Argument describing how the features are grouped. \n        From Celer documentation:\n        \"groupsint | list of ints | list of lists of ints.\n            Partition of features used in the penalty on w. \n                If an int is passed, groups are contiguous blocks of features, of size groups. \n                If a list of ints is passed, groups are assumed to be contiguous, group number g being of size groups[g]. \n                If a list of lists of ints is passed, groups[g] contains the feature indices of the group number g.\"\n        If 1, model will behave identically to Lasso Regression.\n    tifidf_list- a boolean mask where tfidf_list[0] and tfidf_list[1] are respective to adata1 and adata2\n        If True, tfidf normalization will be applied to the respective adata during cross validation\n    starting_alpha- The alpha value to start the search at.\n    alpha_array- Numpy array of all alpha values to be tested\n    k- number of folds to perform cross validation over</p>\n\n<p>Output:\n    sparsity_dict- Dictionary with tested alpha as keys and the number of selected pathways as the values\n    alpha- The alpha value yielding the number of selected groups closest to the target.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">adatas</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">group_size</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">tfidf</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">alpha_array</span><span class=\"o\">=</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">1.9</span><span class=\"p\">,</span> <span class=\"mf\">1.7</span><span class=\"p\">,</span> <span class=\"mf\">1.5</span><span class=\"p\">,</span> <span class=\"mf\">1.3</span><span class=\"p\">,</span> <span class=\"mf\">1.1</span><span class=\"p\">,</span> <span class=\"mf\">0.9</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">])</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">4</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.optimize_alpha.optimize_sparsity", "modulename": "scmkl.optimize_alpha", "qualname": "optimize_sparsity", "kind": "function", "doc": "<p>Iteratively train a grouplasso model and update alpha to find the parameter yielding the desired sparsity.\nThis function is meant to find a good starting point for your model, and the alpha may need further fine tuning.\nInput:\n    adata- Anndata object with Z_train and Z_test calculated\n    group_size- Argument describing how the features are grouped. \n        From Celer documentation:\n        \"groupsint | list of ints | list of lists of ints.\n            Partition of features used in the penalty on w. \n                If an int is passed, groups are contiguous blocks of features, of size groups. \n                If a list of ints is passed, groups are assumed to be contiguous, group number g being of size groups[g]. \n                If a list of lists of ints is passed, groups[g] contains the feature indices of the group number g.\"\n        If 1, model will behave identically to Lasso Regression.\n    starting_alpha- The alpha value to start the search at.\n    increment- amount to adjust alpha by between iterations\n    target- The desired number of groups selected by the model.\n    n_iter- The maximum number of iterations to run</p>\n\n<p>Output:\n    sparsity_dict- Dictionary with tested alpha as keys and the number of selected pathways as the values\n    alpha- The alpha value yielding the number of selected groups closest to the target.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">adata</span>,</span><span class=\"param\">\t<span class=\"n\">group_size</span>,</span><span class=\"param\">\t<span class=\"n\">starting_alpha</span><span class=\"o\">=</span><span class=\"mf\">1.9</span>,</span><span class=\"param\">\t<span class=\"n\">increment</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">n_iter</span><span class=\"o\">=</span><span class=\"mi\">10</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.test", "modulename": "scmkl.test", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "scmkl.test.predict", "modulename": "scmkl.test", "qualname": "predict", "kind": "function", "doc": "<p>Function to return predicted labels and calculate any of AUROC, Accuracy, F1 Score, Precision, Recall for a classification. \nInput:<br />\n        adata- adata object with trained model and Z matrices in uns\n        metrics- Which metrics to calculate on the predicted values</p>\n\n<p>Output:\n        Values predicted by the model\n        Dictionary containing AUROC, Accuracy, F1 Score, Precision, and/or Recall depending on metrics argument</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">adata</span>, </span><span class=\"param\"><span class=\"n\">metrics</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.test.find_selected_groups", "modulename": "scmkl.test", "qualname": "find_selected_groups", "kind": "function", "doc": "<p>Function to find feature groups selected by the model during training.  If feature weight assigned by the model is non-0, then the group containing that feature is selected.\nInputs:\n    model- A trained celer.GroupLasso model.\n    group_names- An iterable object containing the group_names in the same order as the feature groupings from Data array.\nOutpus:\n    Numpy array containing the names of the groups selected by the model.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">adata</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "scmkl.test.calculate_auroc", "modulename": "scmkl.test", "qualname": "calculate_auroc", "kind": "function", "doc": "<p>Function to calculate the AUROC for a classification. \nDesigned as a helper function.  Recommended to use Predict() for model evaluation.\nInput:<br />\n        adata- adata object with trained model and Z matrices in uns\nOutput:\n        Calculated AUROC value</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">adata</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "scmkl.test.extract_kernel_weights", "modulename": "scmkl.test", "qualname": "extract_kernel_weights", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.tfidf", "modulename": "scmkl.tfidf", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "scmkl.tfidf.tfidf_normalize", "modulename": "scmkl.tfidf", "qualname": "tfidf_normalize", "kind": "function", "doc": "<p>Function to TF IDF normalize the data in an adata object\nIf train/test indices are included in the object, it will calculate the normalization separately for the training and testing data\n    Otherwise it will calculate it on the entire dataset\nIf any rows are entirely 0, that row and its metadata will be removed from the object</p>\n\n<p>Input:\n    adata- adata object with data in adata.X to be normalized\n        Can have train/test indices included or not\n    binarize- Boolean option to binarize the data\nOutput:\n    adata- adata object with same attributes as before, but the TF IDF normalized matrix in place of adata.X\n                Will now have the train data stacked on test data, and the indices will be adjusted accordingly</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">adata</span>, </span><span class=\"param\"><span class=\"n\">binarize</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.train", "modulename": "scmkl.train", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "scmkl.train.train_model", "modulename": "scmkl.train", "qualname": "train_model", "kind": "function", "doc": "<p>Function to fit a grouplasso model to the provided data.\nInputs:\n        Adata with Z matrices in adata.uns\n        group_size- Argument describing how the features are grouped. \n                From Celer documentation:\n                \"groupsint | list of ints | list of lists of ints.\n                    Partition of features used in the penalty on w. \n                        If an int is passed, groups are contiguous blocks of features, of size groups. \n                        If a list of ints is passed, groups are assumed to be contiguous, group number g being of size groups[g]. \n                        If a list of lists of ints is passed, groups[g] contains the feature indices of the group number g.\"\n                If 1, model will behave identically to Lasso Regression\n        alpha- Group Lasso regularization coefficient. alpha is a floating point value controlling model solution sparsity. Must be a positive float.\n                    The smaller the value, the more feature groups will be selected in the trained model.\nOutputs:</p>\n\n<pre><code>    adata object with trained model in uns accessible with- adata.uns['model']\n        Specifics of model:\n            model- The trained Celer Group Lasso model.  Used in Find_Selected_Pathways() function for interpretability.\n                For more information about attributes and methods see the Celer documentation at https://mathurinm.github.io/celer/generated/celer.GroupLasso.html.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">adata</span>, </span><span class=\"param\"><span class=\"n\">group_size</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.9</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "scmkl.utils", "modulename": "scmkl.utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "scmkl.utils.run", "modulename": "scmkl.utils", "qualname": "run", "kind": "function", "doc": "<p>Takes a processed AnnData object and creates a model for each\nelement in alpha_list. Return a dictionary with metrics and \npredictions.\nArgs:\n    adata - an AnnData object with 'Z_train', 'Z_test', and \n        'group_dict' keys in adata.uns.\n    alpha_list - a np.ndarray of alpha values to create models \n        using. Alpha refers to the penalty parameter in Group\n        Lasso. Larger alphas force group weights to shrink towards\n        0 while smaller alphas apply a lesser penalty to kernal \n        weights.\n    metrics - a list of strings where each element is a type of \n        metric to be calculated. Options are ['AUROC', 'F1-Score',\n        'Accuracy', 'Precision', 'Recall']. When set to None, all\n        metrics are calculated.\nReturns:\n    A dictionary with keys and values: \n        'Metrics' : a nested dictionary as [alpha][metric] = value\n        'Selected_groups' : a dictionary as [alpha] = array of \n            groups with nonzero weights\n        'Norms' : a dictionary as [alpha] = array of kernel weights\n            for each group, order respective to 'Group_names'\n        'Predictions' : a dictionary as [alpha] = predicted class\n            respective to 'Observations' for that alpha\n        'Observed' : an array of ground truth cell labels from the\n            test set \n        'Test_indices' : indices of samples respective to adata \n            used in the training set\n        'Group_names' : an array of group names respective to each\n            array in 'Norms'\n        'Model' : a dictionary where [alpha] = Celer Group Lasso\n            object for that alpha\n        'RAM_usage' : memory usage after training models for each \n            alpha</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">adata</span><span class=\"p\">:</span> <span class=\"n\">anndata</span><span class=\"o\">.</span><span class=\"n\">_core</span><span class=\"o\">.</span><span class=\"n\">anndata</span><span class=\"o\">.</span><span class=\"n\">AnnData</span>,</span><span class=\"param\">\t<span class=\"n\">alpha_list</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">metrics</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "scmkl.utils.one_v_all", "modulename": "scmkl.utils", "qualname": "one_v_all", "kind": "function", "doc": "<p>This function takes a list of AnnData objects and creates a model\nfor each cell label type.\nArgs:\n    adatas - a list of AnnData objects created by create_adata()\n        where each AnnData is one modality and composed of both \n        training and testing samples. Requires that train_indices\n        and test_indices are the same across all AnnDatas.\n    names - a list of string variables that describe each modality\n        respective to adatas for labeling.\n    cell_labels - as scMKL is a binary classifier, there can only\n        be two cell label types in the adata.obs['labels'] slot.\n        Given this, np.ndarray is required to generate custom cell\n        labels for each type present in the data. Array should \n        coorespond to samples in AnnData objects.\n    remove_labels - If True, models will only be created for cell\n        labels in both the training and test data, if False, models\n        will be generated for all cell labels in the training data.\nReturns:\n    Returns a dictionary of metrics, group weights, trained models\n    for each label vs. the rest, predictions for each model, and a\n    consensus prediction array for each sample in the train set.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">adatas</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">names</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">alpha_list</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">tfidf</span><span class=\"p\">:</span> <span class=\"nb\">list</span>,</span><span class=\"param\">\t<span class=\"n\">D</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">remove_labels</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();